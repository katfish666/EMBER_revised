all_train_losses = []
all_val_losses = []

all_train_accs = []
all_val_accs = []

all_yPreds = []

splits = stratFold
for i, (train_idx,test_idx) in enumerate(splits): ... 5 of these

    #################################### TRAINING PHASE ##########################################

    x_train_fold = x_train[train_idx]
    y_train_fold = y_train[train_idx]

    ### instantiate model
    model = model()
    loss = criterion
    best_model = model
    
    train_losses = []
    val_losses = []
    train_accs = []
    val_accs = []
    
    for j in epochs:
    
        ### train model for an epoch ###############
        model.train()
        train = x
        train_loader = DataLoader(train)
        
        running_loss = 0.0
        running_acc = 0.0
        
        for inputs,labels in enumerate(train_loader):
        
            optimizer.zero_grad()
            outputs = model.forward(inputs)
            loss = criterion(ouputs, labels)
            loss = normalized(loss)
            loss = loss.mean()
            
            loss.backward()
            optimizer.step()
            
            running_loss += loss.item()
            
            ### get accuracy
            y_test = np.asarray(labels.cpu())
            y_score = outputs.cpu().detach().numpy()
            acc = getAcc(y_test, y_score)
            
            running_acc += acc
            
        train_loss = running_loss / len(train_loader)
        train_losses.append(train_loss)
        
        train_acc = running_acc / len(train_loader)
        train_accs.append(train_acc)
        
        #############################################
     
        ### validate model for an epoch #############
        model.evaluate()
        valid = y
        valid_loader = DataLoader(valid)
        
        running_loss = 0.0
        running_acc = 0.0
        best_loss = inf
        
        for inputs,labels in enumerate(valid_loader):
        
            optimizer.zero_grad()
            outputs = model.forward(inputs)
            loss = criterion(ouputs, labels)
            loss = normalized(loss)
            loss = loss.mean()
            
            running_loss += loss.item()
            
            ### get accuracy
            y_test = np.asarray(labels.cpu())
            y_score = outputs.cpu().detach().numpy()
            acc = getAcc(y_test, y_score)
            
            running_acc += acc
            
            if running_loss <= best_loss: ### or maybe do acc ???
                best_model = copy.deepcopy(model.state_dict())
                
        val_loss = running_loss / len(valid_loader)
        val_losses.append(val_loss)
        
        val_acc = running_acc / len(valid_loader)
        val_accs.append(val_acc)
        
        #############################################
        
    all_train_losses.append(train_losses)
    all_val_losses.append(val_losses)
    
    all_train_accs.append(train_accs)
    all_val_accs.append(val_accs)
                
    
    
    #################################### TESTING PHASE ##########################################
    
    model.load_state_dict(best_model_wts)
    
    x_test_fold = x_train[test_idx]
    y_test_fold = y_train[test_idx]
        
        
        
        
        
        
        